
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model University
 * 
 */
export type University = {
  id: number
  code: string
  name: string
}

/**
 * Model Faculty
 * 
 */
export type Faculty = {
  id: number
  name: string
  universityId: number
}

/**
 * Model Curriculum
 * 
 */
export type Curriculum = {
  id: number
  name: string
}

/**
 * Model Subject
 * 
 */
export type Subject = {
  id: number
  name: string
  discipline: string
  grade: number
  curriculumid: number
}

/**
 * Model Programme
 * 
 */
export type Programme = {
  id: number
  name: string
  available_space: number
  facultyid: number
  universityid: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Universities
 * const universities = await prisma.university.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Universities
   * const universities = await prisma.university.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.university`: Exposes CRUD operations for the **University** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Universities
    * const universities = await prisma.university.findMany()
    * ```
    */
  get university(): Prisma.UniversityDelegate<GlobalReject>;

  /**
   * `prisma.faculty`: Exposes CRUD operations for the **Faculty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faculties
    * const faculties = await prisma.faculty.findMany()
    * ```
    */
  get faculty(): Prisma.FacultyDelegate<GlobalReject>;

  /**
   * `prisma.curriculum`: Exposes CRUD operations for the **Curriculum** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Curricula
    * const curricula = await prisma.curriculum.findMany()
    * ```
    */
  get curriculum(): Prisma.CurriculumDelegate<GlobalReject>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<GlobalReject>;

  /**
   * `prisma.programme`: Exposes CRUD operations for the **Programme** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programmes
    * const programmes = await prisma.programme.findMany()
    * ```
    */
  get programme(): Prisma.ProgrammeDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.12.0
   * Query Engine version: 22b822189f46ef0dc5c5b503368d1bee01213980
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    University: 'University',
    Faculty: 'Faculty',
    Curriculum: 'Curriculum',
    Subject: 'Subject',
    Programme: 'Programme'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UniversityCountOutputType
   */


  export type UniversityCountOutputType = {
    faculties: number
    programmes: number
  }

  export type UniversityCountOutputTypeSelect = {
    faculties?: boolean
    programmes?: boolean
  }

  export type UniversityCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UniversityCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UniversityCountOutputType
    : S extends undefined
    ? never
    : S extends UniversityCountOutputTypeArgs
    ?'include' extends U
    ? UniversityCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UniversityCountOutputType ? UniversityCountOutputType[P] : never
  } 
    : UniversityCountOutputType
  : UniversityCountOutputType




  // Custom InputTypes

  /**
   * UniversityCountOutputType without action
   */
  export type UniversityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UniversityCountOutputType
     * 
    **/
    select?: UniversityCountOutputTypeSelect | null
  }



  /**
   * Count Type FacultyCountOutputType
   */


  export type FacultyCountOutputType = {
    programmes: number
  }

  export type FacultyCountOutputTypeSelect = {
    programmes?: boolean
  }

  export type FacultyCountOutputTypeGetPayload<
    S extends boolean | null | undefined | FacultyCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? FacultyCountOutputType
    : S extends undefined
    ? never
    : S extends FacultyCountOutputTypeArgs
    ?'include' extends U
    ? FacultyCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof FacultyCountOutputType ? FacultyCountOutputType[P] : never
  } 
    : FacultyCountOutputType
  : FacultyCountOutputType




  // Custom InputTypes

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FacultyCountOutputType
     * 
    **/
    select?: FacultyCountOutputTypeSelect | null
  }



  /**
   * Count Type CurriculumCountOutputType
   */


  export type CurriculumCountOutputType = {
    subjects: number
  }

  export type CurriculumCountOutputTypeSelect = {
    subjects?: boolean
  }

  export type CurriculumCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CurriculumCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CurriculumCountOutputType
    : S extends undefined
    ? never
    : S extends CurriculumCountOutputTypeArgs
    ?'include' extends U
    ? CurriculumCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CurriculumCountOutputType ? CurriculumCountOutputType[P] : never
  } 
    : CurriculumCountOutputType
  : CurriculumCountOutputType




  // Custom InputTypes

  /**
   * CurriculumCountOutputType without action
   */
  export type CurriculumCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CurriculumCountOutputType
     * 
    **/
    select?: CurriculumCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model University
   */


  export type AggregateUniversity = {
    _count: UniversityCountAggregateOutputType | null
    _avg: UniversityAvgAggregateOutputType | null
    _sum: UniversitySumAggregateOutputType | null
    _min: UniversityMinAggregateOutputType | null
    _max: UniversityMaxAggregateOutputType | null
  }

  export type UniversityAvgAggregateOutputType = {
    id: number | null
  }

  export type UniversitySumAggregateOutputType = {
    id: number | null
  }

  export type UniversityMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
  }

  export type UniversityMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
  }

  export type UniversityCountAggregateOutputType = {
    id: number
    code: number
    name: number
    _all: number
  }


  export type UniversityAvgAggregateInputType = {
    id?: true
  }

  export type UniversitySumAggregateInputType = {
    id?: true
  }

  export type UniversityMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
  }

  export type UniversityMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
  }

  export type UniversityCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    _all?: true
  }

  export type UniversityAggregateArgs = {
    /**
     * Filter which University to aggregate.
     * 
    **/
    where?: UniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Universities to fetch.
     * 
    **/
    orderBy?: Enumerable<UniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Universities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Universities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Universities
    **/
    _count?: true | UniversityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UniversityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UniversitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UniversityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UniversityMaxAggregateInputType
  }

  export type GetUniversityAggregateType<T extends UniversityAggregateArgs> = {
        [P in keyof T & keyof AggregateUniversity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUniversity[P]>
      : GetScalarType<T[P], AggregateUniversity[P]>
  }




  export type UniversityGroupByArgs = {
    where?: UniversityWhereInput
    orderBy?: Enumerable<UniversityOrderByWithAggregationInput>
    by: Array<UniversityScalarFieldEnum>
    having?: UniversityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UniversityCountAggregateInputType | true
    _avg?: UniversityAvgAggregateInputType
    _sum?: UniversitySumAggregateInputType
    _min?: UniversityMinAggregateInputType
    _max?: UniversityMaxAggregateInputType
  }


  export type UniversityGroupByOutputType = {
    id: number
    code: string
    name: string
    _count: UniversityCountAggregateOutputType | null
    _avg: UniversityAvgAggregateOutputType | null
    _sum: UniversitySumAggregateOutputType | null
    _min: UniversityMinAggregateOutputType | null
    _max: UniversityMaxAggregateOutputType | null
  }

  type GetUniversityGroupByPayload<T extends UniversityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UniversityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UniversityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UniversityGroupByOutputType[P]>
            : GetScalarType<T[P], UniversityGroupByOutputType[P]>
        }
      >
    >


  export type UniversitySelect = {
    id?: boolean
    code?: boolean
    name?: boolean
    faculties?: boolean | FacultyFindManyArgs
    programmes?: boolean | ProgrammeFindManyArgs
    _count?: boolean | UniversityCountOutputTypeArgs
  }

  export type UniversityInclude = {
    faculties?: boolean | FacultyFindManyArgs
    programmes?: boolean | ProgrammeFindManyArgs
    _count?: boolean | UniversityCountOutputTypeArgs
  }

  export type UniversityGetPayload<
    S extends boolean | null | undefined | UniversityArgs,
    U = keyof S
      > = S extends true
        ? University
    : S extends undefined
    ? never
    : S extends UniversityArgs | UniversityFindManyArgs
    ?'include' extends U
    ? University  & {
    [P in TrueKeys<S['include']>]:
        P extends 'faculties' ? Array < FacultyGetPayload<S['include'][P]>>  :
        P extends 'programmes' ? Array < ProgrammeGetPayload<S['include'][P]>>  :
        P extends '_count' ? UniversityCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'faculties' ? Array < FacultyGetPayload<S['select'][P]>>  :
        P extends 'programmes' ? Array < ProgrammeGetPayload<S['select'][P]>>  :
        P extends '_count' ? UniversityCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof University ? University[P] : never
  } 
    : University
  : University


  type UniversityCountArgs = Merge<
    Omit<UniversityFindManyArgs, 'select' | 'include'> & {
      select?: UniversityCountAggregateInputType | true
    }
  >

  export interface UniversityDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one University that matches the filter.
     * @param {UniversityFindUniqueArgs} args - Arguments to find a University
     * @example
     * // Get one University
     * const university = await prisma.university.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UniversityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UniversityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'University'> extends True ? CheckSelect<T, Prisma__UniversityClient<University>, Prisma__UniversityClient<UniversityGetPayload<T>>> : CheckSelect<T, Prisma__UniversityClient<University | null >, Prisma__UniversityClient<UniversityGetPayload<T> | null >>

    /**
     * Find the first University that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityFindFirstArgs} args - Arguments to find a University
     * @example
     * // Get one University
     * const university = await prisma.university.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UniversityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UniversityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'University'> extends True ? CheckSelect<T, Prisma__UniversityClient<University>, Prisma__UniversityClient<UniversityGetPayload<T>>> : CheckSelect<T, Prisma__UniversityClient<University | null >, Prisma__UniversityClient<UniversityGetPayload<T> | null >>

    /**
     * Find zero or more Universities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Universities
     * const universities = await prisma.university.findMany()
     * 
     * // Get first 10 Universities
     * const universities = await prisma.university.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const universityWithIdOnly = await prisma.university.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UniversityFindManyArgs>(
      args?: SelectSubset<T, UniversityFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<University>>, PrismaPromise<Array<UniversityGetPayload<T>>>>

    /**
     * Create a University.
     * @param {UniversityCreateArgs} args - Arguments to create a University.
     * @example
     * // Create one University
     * const University = await prisma.university.create({
     *   data: {
     *     // ... data to create a University
     *   }
     * })
     * 
    **/
    create<T extends UniversityCreateArgs>(
      args: SelectSubset<T, UniversityCreateArgs>
    ): CheckSelect<T, Prisma__UniversityClient<University>, Prisma__UniversityClient<UniversityGetPayload<T>>>

    /**
     * Create many Universities.
     *     @param {UniversityCreateManyArgs} args - Arguments to create many Universities.
     *     @example
     *     // Create many Universities
     *     const university = await prisma.university.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UniversityCreateManyArgs>(
      args?: SelectSubset<T, UniversityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a University.
     * @param {UniversityDeleteArgs} args - Arguments to delete one University.
     * @example
     * // Delete one University
     * const University = await prisma.university.delete({
     *   where: {
     *     // ... filter to delete one University
     *   }
     * })
     * 
    **/
    delete<T extends UniversityDeleteArgs>(
      args: SelectSubset<T, UniversityDeleteArgs>
    ): CheckSelect<T, Prisma__UniversityClient<University>, Prisma__UniversityClient<UniversityGetPayload<T>>>

    /**
     * Update one University.
     * @param {UniversityUpdateArgs} args - Arguments to update one University.
     * @example
     * // Update one University
     * const university = await prisma.university.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UniversityUpdateArgs>(
      args: SelectSubset<T, UniversityUpdateArgs>
    ): CheckSelect<T, Prisma__UniversityClient<University>, Prisma__UniversityClient<UniversityGetPayload<T>>>

    /**
     * Delete zero or more Universities.
     * @param {UniversityDeleteManyArgs} args - Arguments to filter Universities to delete.
     * @example
     * // Delete a few Universities
     * const { count } = await prisma.university.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UniversityDeleteManyArgs>(
      args?: SelectSubset<T, UniversityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Universities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Universities
     * const university = await prisma.university.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UniversityUpdateManyArgs>(
      args: SelectSubset<T, UniversityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one University.
     * @param {UniversityUpsertArgs} args - Arguments to update or create a University.
     * @example
     * // Update or create a University
     * const university = await prisma.university.upsert({
     *   create: {
     *     // ... data to create a University
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the University we want to update
     *   }
     * })
    **/
    upsert<T extends UniversityUpsertArgs>(
      args: SelectSubset<T, UniversityUpsertArgs>
    ): CheckSelect<T, Prisma__UniversityClient<University>, Prisma__UniversityClient<UniversityGetPayload<T>>>

    /**
     * Count the number of Universities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityCountArgs} args - Arguments to filter Universities to count.
     * @example
     * // Count the number of Universities
     * const count = await prisma.university.count({
     *   where: {
     *     // ... the filter for the Universities we want to count
     *   }
     * })
    **/
    count<T extends UniversityCountArgs>(
      args?: Subset<T, UniversityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UniversityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a University.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UniversityAggregateArgs>(args: Subset<T, UniversityAggregateArgs>): PrismaPromise<GetUniversityAggregateType<T>>

    /**
     * Group by University.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UniversityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UniversityGroupByArgs['orderBy'] }
        : { orderBy?: UniversityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UniversityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUniversityGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for University.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UniversityClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    faculties<T extends FacultyFindManyArgs = {}>(args?: Subset<T, FacultyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Faculty>>, PrismaPromise<Array<FacultyGetPayload<T>>>>;

    programmes<T extends ProgrammeFindManyArgs = {}>(args?: Subset<T, ProgrammeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Programme>>, PrismaPromise<Array<ProgrammeGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * University findUnique
   */
  export type UniversityFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the University
     * 
    **/
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UniversityInclude | null
    /**
     * Throw an Error if a University can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which University to fetch.
     * 
    **/
    where: UniversityWhereUniqueInput
  }


  /**
   * University findFirst
   */
  export type UniversityFindFirstArgs = {
    /**
     * Select specific fields to fetch from the University
     * 
    **/
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UniversityInclude | null
    /**
     * Throw an Error if a University can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which University to fetch.
     * 
    **/
    where?: UniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Universities to fetch.
     * 
    **/
    orderBy?: Enumerable<UniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Universities.
     * 
    **/
    cursor?: UniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Universities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Universities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Universities.
     * 
    **/
    distinct?: Enumerable<UniversityScalarFieldEnum>
  }


  /**
   * University findMany
   */
  export type UniversityFindManyArgs = {
    /**
     * Select specific fields to fetch from the University
     * 
    **/
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UniversityInclude | null
    /**
     * Filter, which Universities to fetch.
     * 
    **/
    where?: UniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Universities to fetch.
     * 
    **/
    orderBy?: Enumerable<UniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Universities.
     * 
    **/
    cursor?: UniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Universities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Universities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UniversityScalarFieldEnum>
  }


  /**
   * University create
   */
  export type UniversityCreateArgs = {
    /**
     * Select specific fields to fetch from the University
     * 
    **/
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UniversityInclude | null
    /**
     * The data needed to create a University.
     * 
    **/
    data: XOR<UniversityCreateInput, UniversityUncheckedCreateInput>
  }


  /**
   * University createMany
   */
  export type UniversityCreateManyArgs = {
    /**
     * The data used to create many Universities.
     * 
    **/
    data: Enumerable<UniversityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * University update
   */
  export type UniversityUpdateArgs = {
    /**
     * Select specific fields to fetch from the University
     * 
    **/
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UniversityInclude | null
    /**
     * The data needed to update a University.
     * 
    **/
    data: XOR<UniversityUpdateInput, UniversityUncheckedUpdateInput>
    /**
     * Choose, which University to update.
     * 
    **/
    where: UniversityWhereUniqueInput
  }


  /**
   * University updateMany
   */
  export type UniversityUpdateManyArgs = {
    /**
     * The data used to update Universities.
     * 
    **/
    data: XOR<UniversityUpdateManyMutationInput, UniversityUncheckedUpdateManyInput>
    /**
     * Filter which Universities to update
     * 
    **/
    where?: UniversityWhereInput
  }


  /**
   * University upsert
   */
  export type UniversityUpsertArgs = {
    /**
     * Select specific fields to fetch from the University
     * 
    **/
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UniversityInclude | null
    /**
     * The filter to search for the University to update in case it exists.
     * 
    **/
    where: UniversityWhereUniqueInput
    /**
     * In case the University found by the `where` argument doesn't exist, create a new University with this data.
     * 
    **/
    create: XOR<UniversityCreateInput, UniversityUncheckedCreateInput>
    /**
     * In case the University was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UniversityUpdateInput, UniversityUncheckedUpdateInput>
  }


  /**
   * University delete
   */
  export type UniversityDeleteArgs = {
    /**
     * Select specific fields to fetch from the University
     * 
    **/
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UniversityInclude | null
    /**
     * Filter which University to delete.
     * 
    **/
    where: UniversityWhereUniqueInput
  }


  /**
   * University deleteMany
   */
  export type UniversityDeleteManyArgs = {
    /**
     * Filter which Universities to delete
     * 
    **/
    where?: UniversityWhereInput
  }


  /**
   * University without action
   */
  export type UniversityArgs = {
    /**
     * Select specific fields to fetch from the University
     * 
    **/
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UniversityInclude | null
  }



  /**
   * Model Faculty
   */


  export type AggregateFaculty = {
    _count: FacultyCountAggregateOutputType | null
    _avg: FacultyAvgAggregateOutputType | null
    _sum: FacultySumAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  export type FacultyAvgAggregateOutputType = {
    id: number | null
    universityId: number | null
  }

  export type FacultySumAggregateOutputType = {
    id: number | null
    universityId: number | null
  }

  export type FacultyMinAggregateOutputType = {
    id: number | null
    name: string | null
    universityId: number | null
  }

  export type FacultyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    universityId: number | null
  }

  export type FacultyCountAggregateOutputType = {
    id: number
    name: number
    universityId: number
    _all: number
  }


  export type FacultyAvgAggregateInputType = {
    id?: true
    universityId?: true
  }

  export type FacultySumAggregateInputType = {
    id?: true
    universityId?: true
  }

  export type FacultyMinAggregateInputType = {
    id?: true
    name?: true
    universityId?: true
  }

  export type FacultyMaxAggregateInputType = {
    id?: true
    name?: true
    universityId?: true
  }

  export type FacultyCountAggregateInputType = {
    id?: true
    name?: true
    universityId?: true
    _all?: true
  }

  export type FacultyAggregateArgs = {
    /**
     * Filter which Faculty to aggregate.
     * 
    **/
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     * 
    **/
    orderBy?: Enumerable<FacultyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faculties
    **/
    _count?: true | FacultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacultyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacultySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacultyMaxAggregateInputType
  }

  export type GetFacultyAggregateType<T extends FacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateFaculty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaculty[P]>
      : GetScalarType<T[P], AggregateFaculty[P]>
  }




  export type FacultyGroupByArgs = {
    where?: FacultyWhereInput
    orderBy?: Enumerable<FacultyOrderByWithAggregationInput>
    by: Array<FacultyScalarFieldEnum>
    having?: FacultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacultyCountAggregateInputType | true
    _avg?: FacultyAvgAggregateInputType
    _sum?: FacultySumAggregateInputType
    _min?: FacultyMinAggregateInputType
    _max?: FacultyMaxAggregateInputType
  }


  export type FacultyGroupByOutputType = {
    id: number
    name: string
    universityId: number
    _count: FacultyCountAggregateOutputType | null
    _avg: FacultyAvgAggregateOutputType | null
    _sum: FacultySumAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  type GetFacultyGroupByPayload<T extends FacultyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FacultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacultyGroupByOutputType[P]>
            : GetScalarType<T[P], FacultyGroupByOutputType[P]>
        }
      >
    >


  export type FacultySelect = {
    id?: boolean
    name?: boolean
    university?: boolean | UniversityArgs
    universityId?: boolean
    programmes?: boolean | ProgrammeFindManyArgs
    _count?: boolean | FacultyCountOutputTypeArgs
  }

  export type FacultyInclude = {
    university?: boolean | UniversityArgs
    programmes?: boolean | ProgrammeFindManyArgs
    _count?: boolean | FacultyCountOutputTypeArgs
  }

  export type FacultyGetPayload<
    S extends boolean | null | undefined | FacultyArgs,
    U = keyof S
      > = S extends true
        ? Faculty
    : S extends undefined
    ? never
    : S extends FacultyArgs | FacultyFindManyArgs
    ?'include' extends U
    ? Faculty  & {
    [P in TrueKeys<S['include']>]:
        P extends 'university' ? UniversityGetPayload<S['include'][P]> | null :
        P extends 'programmes' ? Array < ProgrammeGetPayload<S['include'][P]>>  :
        P extends '_count' ? FacultyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'university' ? UniversityGetPayload<S['select'][P]> | null :
        P extends 'programmes' ? Array < ProgrammeGetPayload<S['select'][P]>>  :
        P extends '_count' ? FacultyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Faculty ? Faculty[P] : never
  } 
    : Faculty
  : Faculty


  type FacultyCountArgs = Merge<
    Omit<FacultyFindManyArgs, 'select' | 'include'> & {
      select?: FacultyCountAggregateInputType | true
    }
  >

  export interface FacultyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Faculty that matches the filter.
     * @param {FacultyFindUniqueArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacultyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacultyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Faculty'> extends True ? CheckSelect<T, Prisma__FacultyClient<Faculty>, Prisma__FacultyClient<FacultyGetPayload<T>>> : CheckSelect<T, Prisma__FacultyClient<Faculty | null >, Prisma__FacultyClient<FacultyGetPayload<T> | null >>

    /**
     * Find the first Faculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacultyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacultyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Faculty'> extends True ? CheckSelect<T, Prisma__FacultyClient<Faculty>, Prisma__FacultyClient<FacultyGetPayload<T>>> : CheckSelect<T, Prisma__FacultyClient<Faculty | null >, Prisma__FacultyClient<FacultyGetPayload<T> | null >>

    /**
     * Find zero or more Faculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faculties
     * const faculties = await prisma.faculty.findMany()
     * 
     * // Get first 10 Faculties
     * const faculties = await prisma.faculty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facultyWithIdOnly = await prisma.faculty.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacultyFindManyArgs>(
      args?: SelectSubset<T, FacultyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Faculty>>, PrismaPromise<Array<FacultyGetPayload<T>>>>

    /**
     * Create a Faculty.
     * @param {FacultyCreateArgs} args - Arguments to create a Faculty.
     * @example
     * // Create one Faculty
     * const Faculty = await prisma.faculty.create({
     *   data: {
     *     // ... data to create a Faculty
     *   }
     * })
     * 
    **/
    create<T extends FacultyCreateArgs>(
      args: SelectSubset<T, FacultyCreateArgs>
    ): CheckSelect<T, Prisma__FacultyClient<Faculty>, Prisma__FacultyClient<FacultyGetPayload<T>>>

    /**
     * Create many Faculties.
     *     @param {FacultyCreateManyArgs} args - Arguments to create many Faculties.
     *     @example
     *     // Create many Faculties
     *     const faculty = await prisma.faculty.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacultyCreateManyArgs>(
      args?: SelectSubset<T, FacultyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Faculty.
     * @param {FacultyDeleteArgs} args - Arguments to delete one Faculty.
     * @example
     * // Delete one Faculty
     * const Faculty = await prisma.faculty.delete({
     *   where: {
     *     // ... filter to delete one Faculty
     *   }
     * })
     * 
    **/
    delete<T extends FacultyDeleteArgs>(
      args: SelectSubset<T, FacultyDeleteArgs>
    ): CheckSelect<T, Prisma__FacultyClient<Faculty>, Prisma__FacultyClient<FacultyGetPayload<T>>>

    /**
     * Update one Faculty.
     * @param {FacultyUpdateArgs} args - Arguments to update one Faculty.
     * @example
     * // Update one Faculty
     * const faculty = await prisma.faculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacultyUpdateArgs>(
      args: SelectSubset<T, FacultyUpdateArgs>
    ): CheckSelect<T, Prisma__FacultyClient<Faculty>, Prisma__FacultyClient<FacultyGetPayload<T>>>

    /**
     * Delete zero or more Faculties.
     * @param {FacultyDeleteManyArgs} args - Arguments to filter Faculties to delete.
     * @example
     * // Delete a few Faculties
     * const { count } = await prisma.faculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacultyDeleteManyArgs>(
      args?: SelectSubset<T, FacultyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faculties
     * const faculty = await prisma.faculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacultyUpdateManyArgs>(
      args: SelectSubset<T, FacultyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Faculty.
     * @param {FacultyUpsertArgs} args - Arguments to update or create a Faculty.
     * @example
     * // Update or create a Faculty
     * const faculty = await prisma.faculty.upsert({
     *   create: {
     *     // ... data to create a Faculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faculty we want to update
     *   }
     * })
    **/
    upsert<T extends FacultyUpsertArgs>(
      args: SelectSubset<T, FacultyUpsertArgs>
    ): CheckSelect<T, Prisma__FacultyClient<Faculty>, Prisma__FacultyClient<FacultyGetPayload<T>>>

    /**
     * Count the number of Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyCountArgs} args - Arguments to filter Faculties to count.
     * @example
     * // Count the number of Faculties
     * const count = await prisma.faculty.count({
     *   where: {
     *     // ... the filter for the Faculties we want to count
     *   }
     * })
    **/
    count<T extends FacultyCountArgs>(
      args?: Subset<T, FacultyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacultyAggregateArgs>(args: Subset<T, FacultyAggregateArgs>): PrismaPromise<GetFacultyAggregateType<T>>

    /**
     * Group by Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacultyGroupByArgs['orderBy'] }
        : { orderBy?: FacultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacultyGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Faculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacultyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    university<T extends UniversityArgs = {}>(args?: Subset<T, UniversityArgs>): CheckSelect<T, Prisma__UniversityClient<University | null >, Prisma__UniversityClient<UniversityGetPayload<T> | null >>;

    programmes<T extends ProgrammeFindManyArgs = {}>(args?: Subset<T, ProgrammeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Programme>>, PrismaPromise<Array<ProgrammeGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Faculty findUnique
   */
  export type FacultyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Faculty
     * 
    **/
    select?: FacultySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacultyInclude | null
    /**
     * Throw an Error if a Faculty can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Faculty to fetch.
     * 
    **/
    where: FacultyWhereUniqueInput
  }


  /**
   * Faculty findFirst
   */
  export type FacultyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Faculty
     * 
    **/
    select?: FacultySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacultyInclude | null
    /**
     * Throw an Error if a Faculty can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Faculty to fetch.
     * 
    **/
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     * 
    **/
    orderBy?: Enumerable<FacultyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faculties.
     * 
    **/
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faculties.
     * 
    **/
    distinct?: Enumerable<FacultyScalarFieldEnum>
  }


  /**
   * Faculty findMany
   */
  export type FacultyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Faculty
     * 
    **/
    select?: FacultySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacultyInclude | null
    /**
     * Filter, which Faculties to fetch.
     * 
    **/
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     * 
    **/
    orderBy?: Enumerable<FacultyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faculties.
     * 
    **/
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FacultyScalarFieldEnum>
  }


  /**
   * Faculty create
   */
  export type FacultyCreateArgs = {
    /**
     * Select specific fields to fetch from the Faculty
     * 
    **/
    select?: FacultySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacultyInclude | null
    /**
     * The data needed to create a Faculty.
     * 
    **/
    data: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
  }


  /**
   * Faculty createMany
   */
  export type FacultyCreateManyArgs = {
    /**
     * The data used to create many Faculties.
     * 
    **/
    data: Enumerable<FacultyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Faculty update
   */
  export type FacultyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Faculty
     * 
    **/
    select?: FacultySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacultyInclude | null
    /**
     * The data needed to update a Faculty.
     * 
    **/
    data: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
    /**
     * Choose, which Faculty to update.
     * 
    **/
    where: FacultyWhereUniqueInput
  }


  /**
   * Faculty updateMany
   */
  export type FacultyUpdateManyArgs = {
    /**
     * The data used to update Faculties.
     * 
    **/
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyInput>
    /**
     * Filter which Faculties to update
     * 
    **/
    where?: FacultyWhereInput
  }


  /**
   * Faculty upsert
   */
  export type FacultyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Faculty
     * 
    **/
    select?: FacultySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacultyInclude | null
    /**
     * The filter to search for the Faculty to update in case it exists.
     * 
    **/
    where: FacultyWhereUniqueInput
    /**
     * In case the Faculty found by the `where` argument doesn't exist, create a new Faculty with this data.
     * 
    **/
    create: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
    /**
     * In case the Faculty was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
  }


  /**
   * Faculty delete
   */
  export type FacultyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Faculty
     * 
    **/
    select?: FacultySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacultyInclude | null
    /**
     * Filter which Faculty to delete.
     * 
    **/
    where: FacultyWhereUniqueInput
  }


  /**
   * Faculty deleteMany
   */
  export type FacultyDeleteManyArgs = {
    /**
     * Filter which Faculties to delete
     * 
    **/
    where?: FacultyWhereInput
  }


  /**
   * Faculty without action
   */
  export type FacultyArgs = {
    /**
     * Select specific fields to fetch from the Faculty
     * 
    **/
    select?: FacultySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacultyInclude | null
  }



  /**
   * Model Curriculum
   */


  export type AggregateCurriculum = {
    _count: CurriculumCountAggregateOutputType | null
    _avg: CurriculumAvgAggregateOutputType | null
    _sum: CurriculumSumAggregateOutputType | null
    _min: CurriculumMinAggregateOutputType | null
    _max: CurriculumMaxAggregateOutputType | null
  }

  export type CurriculumAvgAggregateOutputType = {
    id: number | null
  }

  export type CurriculumSumAggregateOutputType = {
    id: number | null
  }

  export type CurriculumMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CurriculumMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CurriculumCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CurriculumAvgAggregateInputType = {
    id?: true
  }

  export type CurriculumSumAggregateInputType = {
    id?: true
  }

  export type CurriculumMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CurriculumMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CurriculumCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CurriculumAggregateArgs = {
    /**
     * Filter which Curriculum to aggregate.
     * 
    **/
    where?: CurriculumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Curricula to fetch.
     * 
    **/
    orderBy?: Enumerable<CurriculumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CurriculumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Curricula from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Curricula.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Curricula
    **/
    _count?: true | CurriculumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurriculumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurriculumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurriculumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurriculumMaxAggregateInputType
  }

  export type GetCurriculumAggregateType<T extends CurriculumAggregateArgs> = {
        [P in keyof T & keyof AggregateCurriculum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurriculum[P]>
      : GetScalarType<T[P], AggregateCurriculum[P]>
  }




  export type CurriculumGroupByArgs = {
    where?: CurriculumWhereInput
    orderBy?: Enumerable<CurriculumOrderByWithAggregationInput>
    by: Array<CurriculumScalarFieldEnum>
    having?: CurriculumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurriculumCountAggregateInputType | true
    _avg?: CurriculumAvgAggregateInputType
    _sum?: CurriculumSumAggregateInputType
    _min?: CurriculumMinAggregateInputType
    _max?: CurriculumMaxAggregateInputType
  }


  export type CurriculumGroupByOutputType = {
    id: number
    name: string
    _count: CurriculumCountAggregateOutputType | null
    _avg: CurriculumAvgAggregateOutputType | null
    _sum: CurriculumSumAggregateOutputType | null
    _min: CurriculumMinAggregateOutputType | null
    _max: CurriculumMaxAggregateOutputType | null
  }

  type GetCurriculumGroupByPayload<T extends CurriculumGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CurriculumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurriculumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurriculumGroupByOutputType[P]>
            : GetScalarType<T[P], CurriculumGroupByOutputType[P]>
        }
      >
    >


  export type CurriculumSelect = {
    id?: boolean
    name?: boolean
    subjects?: boolean | SubjectFindManyArgs
    _count?: boolean | CurriculumCountOutputTypeArgs
  }

  export type CurriculumInclude = {
    subjects?: boolean | SubjectFindManyArgs
    _count?: boolean | CurriculumCountOutputTypeArgs
  }

  export type CurriculumGetPayload<
    S extends boolean | null | undefined | CurriculumArgs,
    U = keyof S
      > = S extends true
        ? Curriculum
    : S extends undefined
    ? never
    : S extends CurriculumArgs | CurriculumFindManyArgs
    ?'include' extends U
    ? Curriculum  & {
    [P in TrueKeys<S['include']>]:
        P extends 'subjects' ? Array < SubjectGetPayload<S['include'][P]>>  :
        P extends '_count' ? CurriculumCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'subjects' ? Array < SubjectGetPayload<S['select'][P]>>  :
        P extends '_count' ? CurriculumCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Curriculum ? Curriculum[P] : never
  } 
    : Curriculum
  : Curriculum


  type CurriculumCountArgs = Merge<
    Omit<CurriculumFindManyArgs, 'select' | 'include'> & {
      select?: CurriculumCountAggregateInputType | true
    }
  >

  export interface CurriculumDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Curriculum that matches the filter.
     * @param {CurriculumFindUniqueArgs} args - Arguments to find a Curriculum
     * @example
     * // Get one Curriculum
     * const curriculum = await prisma.curriculum.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CurriculumFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CurriculumFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Curriculum'> extends True ? CheckSelect<T, Prisma__CurriculumClient<Curriculum>, Prisma__CurriculumClient<CurriculumGetPayload<T>>> : CheckSelect<T, Prisma__CurriculumClient<Curriculum | null >, Prisma__CurriculumClient<CurriculumGetPayload<T> | null >>

    /**
     * Find the first Curriculum that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumFindFirstArgs} args - Arguments to find a Curriculum
     * @example
     * // Get one Curriculum
     * const curriculum = await prisma.curriculum.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CurriculumFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CurriculumFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Curriculum'> extends True ? CheckSelect<T, Prisma__CurriculumClient<Curriculum>, Prisma__CurriculumClient<CurriculumGetPayload<T>>> : CheckSelect<T, Prisma__CurriculumClient<Curriculum | null >, Prisma__CurriculumClient<CurriculumGetPayload<T> | null >>

    /**
     * Find zero or more Curricula that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Curricula
     * const curricula = await prisma.curriculum.findMany()
     * 
     * // Get first 10 Curricula
     * const curricula = await prisma.curriculum.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const curriculumWithIdOnly = await prisma.curriculum.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CurriculumFindManyArgs>(
      args?: SelectSubset<T, CurriculumFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Curriculum>>, PrismaPromise<Array<CurriculumGetPayload<T>>>>

    /**
     * Create a Curriculum.
     * @param {CurriculumCreateArgs} args - Arguments to create a Curriculum.
     * @example
     * // Create one Curriculum
     * const Curriculum = await prisma.curriculum.create({
     *   data: {
     *     // ... data to create a Curriculum
     *   }
     * })
     * 
    **/
    create<T extends CurriculumCreateArgs>(
      args: SelectSubset<T, CurriculumCreateArgs>
    ): CheckSelect<T, Prisma__CurriculumClient<Curriculum>, Prisma__CurriculumClient<CurriculumGetPayload<T>>>

    /**
     * Create many Curricula.
     *     @param {CurriculumCreateManyArgs} args - Arguments to create many Curricula.
     *     @example
     *     // Create many Curricula
     *     const curriculum = await prisma.curriculum.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CurriculumCreateManyArgs>(
      args?: SelectSubset<T, CurriculumCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Curriculum.
     * @param {CurriculumDeleteArgs} args - Arguments to delete one Curriculum.
     * @example
     * // Delete one Curriculum
     * const Curriculum = await prisma.curriculum.delete({
     *   where: {
     *     // ... filter to delete one Curriculum
     *   }
     * })
     * 
    **/
    delete<T extends CurriculumDeleteArgs>(
      args: SelectSubset<T, CurriculumDeleteArgs>
    ): CheckSelect<T, Prisma__CurriculumClient<Curriculum>, Prisma__CurriculumClient<CurriculumGetPayload<T>>>

    /**
     * Update one Curriculum.
     * @param {CurriculumUpdateArgs} args - Arguments to update one Curriculum.
     * @example
     * // Update one Curriculum
     * const curriculum = await prisma.curriculum.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CurriculumUpdateArgs>(
      args: SelectSubset<T, CurriculumUpdateArgs>
    ): CheckSelect<T, Prisma__CurriculumClient<Curriculum>, Prisma__CurriculumClient<CurriculumGetPayload<T>>>

    /**
     * Delete zero or more Curricula.
     * @param {CurriculumDeleteManyArgs} args - Arguments to filter Curricula to delete.
     * @example
     * // Delete a few Curricula
     * const { count } = await prisma.curriculum.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CurriculumDeleteManyArgs>(
      args?: SelectSubset<T, CurriculumDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Curricula.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Curricula
     * const curriculum = await prisma.curriculum.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CurriculumUpdateManyArgs>(
      args: SelectSubset<T, CurriculumUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Curriculum.
     * @param {CurriculumUpsertArgs} args - Arguments to update or create a Curriculum.
     * @example
     * // Update or create a Curriculum
     * const curriculum = await prisma.curriculum.upsert({
     *   create: {
     *     // ... data to create a Curriculum
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Curriculum we want to update
     *   }
     * })
    **/
    upsert<T extends CurriculumUpsertArgs>(
      args: SelectSubset<T, CurriculumUpsertArgs>
    ): CheckSelect<T, Prisma__CurriculumClient<Curriculum>, Prisma__CurriculumClient<CurriculumGetPayload<T>>>

    /**
     * Count the number of Curricula.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumCountArgs} args - Arguments to filter Curricula to count.
     * @example
     * // Count the number of Curricula
     * const count = await prisma.curriculum.count({
     *   where: {
     *     // ... the filter for the Curricula we want to count
     *   }
     * })
    **/
    count<T extends CurriculumCountArgs>(
      args?: Subset<T, CurriculumCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurriculumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Curriculum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurriculumAggregateArgs>(args: Subset<T, CurriculumAggregateArgs>): PrismaPromise<GetCurriculumAggregateType<T>>

    /**
     * Group by Curriculum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurriculumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurriculumGroupByArgs['orderBy'] }
        : { orderBy?: CurriculumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurriculumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurriculumGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Curriculum.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CurriculumClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    subjects<T extends SubjectFindManyArgs = {}>(args?: Subset<T, SubjectFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Subject>>, PrismaPromise<Array<SubjectGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Curriculum findUnique
   */
  export type CurriculumFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Curriculum
     * 
    **/
    select?: CurriculumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CurriculumInclude | null
    /**
     * Throw an Error if a Curriculum can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Curriculum to fetch.
     * 
    **/
    where: CurriculumWhereUniqueInput
  }


  /**
   * Curriculum findFirst
   */
  export type CurriculumFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Curriculum
     * 
    **/
    select?: CurriculumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CurriculumInclude | null
    /**
     * Throw an Error if a Curriculum can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Curriculum to fetch.
     * 
    **/
    where?: CurriculumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Curricula to fetch.
     * 
    **/
    orderBy?: Enumerable<CurriculumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Curricula.
     * 
    **/
    cursor?: CurriculumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Curricula from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Curricula.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Curricula.
     * 
    **/
    distinct?: Enumerable<CurriculumScalarFieldEnum>
  }


  /**
   * Curriculum findMany
   */
  export type CurriculumFindManyArgs = {
    /**
     * Select specific fields to fetch from the Curriculum
     * 
    **/
    select?: CurriculumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CurriculumInclude | null
    /**
     * Filter, which Curricula to fetch.
     * 
    **/
    where?: CurriculumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Curricula to fetch.
     * 
    **/
    orderBy?: Enumerable<CurriculumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Curricula.
     * 
    **/
    cursor?: CurriculumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Curricula from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Curricula.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CurriculumScalarFieldEnum>
  }


  /**
   * Curriculum create
   */
  export type CurriculumCreateArgs = {
    /**
     * Select specific fields to fetch from the Curriculum
     * 
    **/
    select?: CurriculumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CurriculumInclude | null
    /**
     * The data needed to create a Curriculum.
     * 
    **/
    data: XOR<CurriculumCreateInput, CurriculumUncheckedCreateInput>
  }


  /**
   * Curriculum createMany
   */
  export type CurriculumCreateManyArgs = {
    /**
     * The data used to create many Curricula.
     * 
    **/
    data: Enumerable<CurriculumCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Curriculum update
   */
  export type CurriculumUpdateArgs = {
    /**
     * Select specific fields to fetch from the Curriculum
     * 
    **/
    select?: CurriculumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CurriculumInclude | null
    /**
     * The data needed to update a Curriculum.
     * 
    **/
    data: XOR<CurriculumUpdateInput, CurriculumUncheckedUpdateInput>
    /**
     * Choose, which Curriculum to update.
     * 
    **/
    where: CurriculumWhereUniqueInput
  }


  /**
   * Curriculum updateMany
   */
  export type CurriculumUpdateManyArgs = {
    /**
     * The data used to update Curricula.
     * 
    **/
    data: XOR<CurriculumUpdateManyMutationInput, CurriculumUncheckedUpdateManyInput>
    /**
     * Filter which Curricula to update
     * 
    **/
    where?: CurriculumWhereInput
  }


  /**
   * Curriculum upsert
   */
  export type CurriculumUpsertArgs = {
    /**
     * Select specific fields to fetch from the Curriculum
     * 
    **/
    select?: CurriculumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CurriculumInclude | null
    /**
     * The filter to search for the Curriculum to update in case it exists.
     * 
    **/
    where: CurriculumWhereUniqueInput
    /**
     * In case the Curriculum found by the `where` argument doesn't exist, create a new Curriculum with this data.
     * 
    **/
    create: XOR<CurriculumCreateInput, CurriculumUncheckedCreateInput>
    /**
     * In case the Curriculum was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CurriculumUpdateInput, CurriculumUncheckedUpdateInput>
  }


  /**
   * Curriculum delete
   */
  export type CurriculumDeleteArgs = {
    /**
     * Select specific fields to fetch from the Curriculum
     * 
    **/
    select?: CurriculumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CurriculumInclude | null
    /**
     * Filter which Curriculum to delete.
     * 
    **/
    where: CurriculumWhereUniqueInput
  }


  /**
   * Curriculum deleteMany
   */
  export type CurriculumDeleteManyArgs = {
    /**
     * Filter which Curricula to delete
     * 
    **/
    where?: CurriculumWhereInput
  }


  /**
   * Curriculum without action
   */
  export type CurriculumArgs = {
    /**
     * Select specific fields to fetch from the Curriculum
     * 
    **/
    select?: CurriculumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CurriculumInclude | null
  }



  /**
   * Model Subject
   */


  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectAvgAggregateOutputType = {
    id: number | null
    grade: number | null
    curriculumid: number | null
  }

  export type SubjectSumAggregateOutputType = {
    id: number | null
    grade: number | null
    curriculumid: number | null
  }

  export type SubjectMinAggregateOutputType = {
    id: number | null
    name: string | null
    discipline: string | null
    grade: number | null
    curriculumid: number | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: number | null
    name: string | null
    discipline: string | null
    grade: number | null
    curriculumid: number | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    name: number
    discipline: number
    grade: number
    curriculumid: number
    _all: number
  }


  export type SubjectAvgAggregateInputType = {
    id?: true
    grade?: true
    curriculumid?: true
  }

  export type SubjectSumAggregateInputType = {
    id?: true
    grade?: true
    curriculumid?: true
  }

  export type SubjectMinAggregateInputType = {
    id?: true
    name?: true
    discipline?: true
    grade?: true
    curriculumid?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    name?: true
    discipline?: true
    grade?: true
    curriculumid?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    name?: true
    discipline?: true
    grade?: true
    curriculumid?: true
    _all?: true
  }

  export type SubjectAggregateArgs = {
    /**
     * Filter which Subject to aggregate.
     * 
    **/
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     * 
    **/
    orderBy?: Enumerable<SubjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs = {
    where?: SubjectWhereInput
    orderBy?: Enumerable<SubjectOrderByWithAggregationInput>
    by: Array<SubjectScalarFieldEnum>
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _avg?: SubjectAvgAggregateInputType
    _sum?: SubjectSumAggregateInputType
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }


  export type SubjectGroupByOutputType = {
    id: number
    name: string
    discipline: string
    grade: number
    curriculumid: number
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect = {
    id?: boolean
    name?: boolean
    discipline?: boolean
    grade?: boolean
    curriculum?: boolean | CurriculumArgs
    curriculumid?: boolean
  }

  export type SubjectInclude = {
    curriculum?: boolean | CurriculumArgs
  }

  export type SubjectGetPayload<
    S extends boolean | null | undefined | SubjectArgs,
    U = keyof S
      > = S extends true
        ? Subject
    : S extends undefined
    ? never
    : S extends SubjectArgs | SubjectFindManyArgs
    ?'include' extends U
    ? Subject  & {
    [P in TrueKeys<S['include']>]:
        P extends 'curriculum' ? CurriculumGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'curriculum' ? CurriculumGetPayload<S['select'][P]> | null :  P extends keyof Subject ? Subject[P] : never
  } 
    : Subject
  : Subject


  type SubjectCountArgs = Merge<
    Omit<SubjectFindManyArgs, 'select' | 'include'> & {
      select?: SubjectCountAggregateInputType | true
    }
  >

  export interface SubjectDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubjectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubjectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Subject'> extends True ? CheckSelect<T, Prisma__SubjectClient<Subject>, Prisma__SubjectClient<SubjectGetPayload<T>>> : CheckSelect<T, Prisma__SubjectClient<Subject | null >, Prisma__SubjectClient<SubjectGetPayload<T> | null >>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubjectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubjectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Subject'> extends True ? CheckSelect<T, Prisma__SubjectClient<Subject>, Prisma__SubjectClient<SubjectGetPayload<T>>> : CheckSelect<T, Prisma__SubjectClient<Subject | null >, Prisma__SubjectClient<SubjectGetPayload<T> | null >>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubjectFindManyArgs>(
      args?: SelectSubset<T, SubjectFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Subject>>, PrismaPromise<Array<SubjectGetPayload<T>>>>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
    **/
    create<T extends SubjectCreateArgs>(
      args: SelectSubset<T, SubjectCreateArgs>
    ): CheckSelect<T, Prisma__SubjectClient<Subject>, Prisma__SubjectClient<SubjectGetPayload<T>>>

    /**
     * Create many Subjects.
     *     @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     *     @example
     *     // Create many Subjects
     *     const subject = await prisma.subject.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubjectCreateManyArgs>(
      args?: SelectSubset<T, SubjectCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
    **/
    delete<T extends SubjectDeleteArgs>(
      args: SelectSubset<T, SubjectDeleteArgs>
    ): CheckSelect<T, Prisma__SubjectClient<Subject>, Prisma__SubjectClient<SubjectGetPayload<T>>>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubjectUpdateArgs>(
      args: SelectSubset<T, SubjectUpdateArgs>
    ): CheckSelect<T, Prisma__SubjectClient<Subject>, Prisma__SubjectClient<SubjectGetPayload<T>>>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubjectDeleteManyArgs>(
      args?: SelectSubset<T, SubjectDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubjectUpdateManyArgs>(
      args: SelectSubset<T, SubjectUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
    **/
    upsert<T extends SubjectUpsertArgs>(
      args: SelectSubset<T, SubjectUpsertArgs>
    ): CheckSelect<T, Prisma__SubjectClient<Subject>, Prisma__SubjectClient<SubjectGetPayload<T>>>

    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubjectClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    curriculum<T extends CurriculumArgs = {}>(args?: Subset<T, CurriculumArgs>): CheckSelect<T, Prisma__CurriculumClient<Curriculum | null >, Prisma__CurriculumClient<CurriculumGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Subject
     * 
    **/
    select?: SubjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubjectInclude | null
    /**
     * Throw an Error if a Subject can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Subject to fetch.
     * 
    **/
    where: SubjectWhereUniqueInput
  }


  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Subject
     * 
    **/
    select?: SubjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubjectInclude | null
    /**
     * Throw an Error if a Subject can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Subject to fetch.
     * 
    **/
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     * 
    **/
    orderBy?: Enumerable<SubjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     * 
    **/
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     * 
    **/
    distinct?: Enumerable<SubjectScalarFieldEnum>
  }


  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs = {
    /**
     * Select specific fields to fetch from the Subject
     * 
    **/
    select?: SubjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubjectInclude | null
    /**
     * Filter, which Subjects to fetch.
     * 
    **/
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     * 
    **/
    orderBy?: Enumerable<SubjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     * 
    **/
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubjectScalarFieldEnum>
  }


  /**
   * Subject create
   */
  export type SubjectCreateArgs = {
    /**
     * Select specific fields to fetch from the Subject
     * 
    **/
    select?: SubjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubjectInclude | null
    /**
     * The data needed to create a Subject.
     * 
    **/
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }


  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs = {
    /**
     * The data used to create many Subjects.
     * 
    **/
    data: Enumerable<SubjectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Subject update
   */
  export type SubjectUpdateArgs = {
    /**
     * Select specific fields to fetch from the Subject
     * 
    **/
    select?: SubjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubjectInclude | null
    /**
     * The data needed to update a Subject.
     * 
    **/
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     * 
    **/
    where: SubjectWhereUniqueInput
  }


  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs = {
    /**
     * The data used to update Subjects.
     * 
    **/
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     * 
    **/
    where?: SubjectWhereInput
  }


  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs = {
    /**
     * Select specific fields to fetch from the Subject
     * 
    **/
    select?: SubjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubjectInclude | null
    /**
     * The filter to search for the Subject to update in case it exists.
     * 
    **/
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     * 
    **/
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }


  /**
   * Subject delete
   */
  export type SubjectDeleteArgs = {
    /**
     * Select specific fields to fetch from the Subject
     * 
    **/
    select?: SubjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubjectInclude | null
    /**
     * Filter which Subject to delete.
     * 
    **/
    where: SubjectWhereUniqueInput
  }


  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs = {
    /**
     * Filter which Subjects to delete
     * 
    **/
    where?: SubjectWhereInput
  }


  /**
   * Subject without action
   */
  export type SubjectArgs = {
    /**
     * Select specific fields to fetch from the Subject
     * 
    **/
    select?: SubjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubjectInclude | null
  }



  /**
   * Model Programme
   */


  export type AggregateProgramme = {
    _count: ProgrammeCountAggregateOutputType | null
    _avg: ProgrammeAvgAggregateOutputType | null
    _sum: ProgrammeSumAggregateOutputType | null
    _min: ProgrammeMinAggregateOutputType | null
    _max: ProgrammeMaxAggregateOutputType | null
  }

  export type ProgrammeAvgAggregateOutputType = {
    id: number | null
    available_space: number | null
    facultyid: number | null
    universityid: number | null
  }

  export type ProgrammeSumAggregateOutputType = {
    id: number | null
    available_space: number | null
    facultyid: number | null
    universityid: number | null
  }

  export type ProgrammeMinAggregateOutputType = {
    id: number | null
    name: string | null
    available_space: number | null
    facultyid: number | null
    universityid: number | null
  }

  export type ProgrammeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    available_space: number | null
    facultyid: number | null
    universityid: number | null
  }

  export type ProgrammeCountAggregateOutputType = {
    id: number
    name: number
    available_space: number
    facultyid: number
    universityid: number
    _all: number
  }


  export type ProgrammeAvgAggregateInputType = {
    id?: true
    available_space?: true
    facultyid?: true
    universityid?: true
  }

  export type ProgrammeSumAggregateInputType = {
    id?: true
    available_space?: true
    facultyid?: true
    universityid?: true
  }

  export type ProgrammeMinAggregateInputType = {
    id?: true
    name?: true
    available_space?: true
    facultyid?: true
    universityid?: true
  }

  export type ProgrammeMaxAggregateInputType = {
    id?: true
    name?: true
    available_space?: true
    facultyid?: true
    universityid?: true
  }

  export type ProgrammeCountAggregateInputType = {
    id?: true
    name?: true
    available_space?: true
    facultyid?: true
    universityid?: true
    _all?: true
  }

  export type ProgrammeAggregateArgs = {
    /**
     * Filter which Programme to aggregate.
     * 
    **/
    where?: ProgrammeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programmes to fetch.
     * 
    **/
    orderBy?: Enumerable<ProgrammeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProgrammeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programmes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programmes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programmes
    **/
    _count?: true | ProgrammeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgrammeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgrammeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgrammeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgrammeMaxAggregateInputType
  }

  export type GetProgrammeAggregateType<T extends ProgrammeAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramme]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramme[P]>
      : GetScalarType<T[P], AggregateProgramme[P]>
  }




  export type ProgrammeGroupByArgs = {
    where?: ProgrammeWhereInput
    orderBy?: Enumerable<ProgrammeOrderByWithAggregationInput>
    by: Array<ProgrammeScalarFieldEnum>
    having?: ProgrammeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgrammeCountAggregateInputType | true
    _avg?: ProgrammeAvgAggregateInputType
    _sum?: ProgrammeSumAggregateInputType
    _min?: ProgrammeMinAggregateInputType
    _max?: ProgrammeMaxAggregateInputType
  }


  export type ProgrammeGroupByOutputType = {
    id: number
    name: string
    available_space: number
    facultyid: number
    universityid: number
    _count: ProgrammeCountAggregateOutputType | null
    _avg: ProgrammeAvgAggregateOutputType | null
    _sum: ProgrammeSumAggregateOutputType | null
    _min: ProgrammeMinAggregateOutputType | null
    _max: ProgrammeMaxAggregateOutputType | null
  }

  type GetProgrammeGroupByPayload<T extends ProgrammeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProgrammeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgrammeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgrammeGroupByOutputType[P]>
            : GetScalarType<T[P], ProgrammeGroupByOutputType[P]>
        }
      >
    >


  export type ProgrammeSelect = {
    id?: boolean
    name?: boolean
    available_space?: boolean
    faculty?: boolean | FacultyArgs
    university?: boolean | UniversityArgs
    facultyid?: boolean
    universityid?: boolean
  }

  export type ProgrammeInclude = {
    faculty?: boolean | FacultyArgs
    university?: boolean | UniversityArgs
  }

  export type ProgrammeGetPayload<
    S extends boolean | null | undefined | ProgrammeArgs,
    U = keyof S
      > = S extends true
        ? Programme
    : S extends undefined
    ? never
    : S extends ProgrammeArgs | ProgrammeFindManyArgs
    ?'include' extends U
    ? Programme  & {
    [P in TrueKeys<S['include']>]:
        P extends 'faculty' ? FacultyGetPayload<S['include'][P]> | null :
        P extends 'university' ? UniversityGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'faculty' ? FacultyGetPayload<S['select'][P]> | null :
        P extends 'university' ? UniversityGetPayload<S['select'][P]> | null :  P extends keyof Programme ? Programme[P] : never
  } 
    : Programme
  : Programme


  type ProgrammeCountArgs = Merge<
    Omit<ProgrammeFindManyArgs, 'select' | 'include'> & {
      select?: ProgrammeCountAggregateInputType | true
    }
  >

  export interface ProgrammeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Programme that matches the filter.
     * @param {ProgrammeFindUniqueArgs} args - Arguments to find a Programme
     * @example
     * // Get one Programme
     * const programme = await prisma.programme.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProgrammeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProgrammeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Programme'> extends True ? CheckSelect<T, Prisma__ProgrammeClient<Programme>, Prisma__ProgrammeClient<ProgrammeGetPayload<T>>> : CheckSelect<T, Prisma__ProgrammeClient<Programme | null >, Prisma__ProgrammeClient<ProgrammeGetPayload<T> | null >>

    /**
     * Find the first Programme that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeFindFirstArgs} args - Arguments to find a Programme
     * @example
     * // Get one Programme
     * const programme = await prisma.programme.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProgrammeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProgrammeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Programme'> extends True ? CheckSelect<T, Prisma__ProgrammeClient<Programme>, Prisma__ProgrammeClient<ProgrammeGetPayload<T>>> : CheckSelect<T, Prisma__ProgrammeClient<Programme | null >, Prisma__ProgrammeClient<ProgrammeGetPayload<T> | null >>

    /**
     * Find zero or more Programmes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programmes
     * const programmes = await prisma.programme.findMany()
     * 
     * // Get first 10 Programmes
     * const programmes = await prisma.programme.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programmeWithIdOnly = await prisma.programme.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProgrammeFindManyArgs>(
      args?: SelectSubset<T, ProgrammeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Programme>>, PrismaPromise<Array<ProgrammeGetPayload<T>>>>

    /**
     * Create a Programme.
     * @param {ProgrammeCreateArgs} args - Arguments to create a Programme.
     * @example
     * // Create one Programme
     * const Programme = await prisma.programme.create({
     *   data: {
     *     // ... data to create a Programme
     *   }
     * })
     * 
    **/
    create<T extends ProgrammeCreateArgs>(
      args: SelectSubset<T, ProgrammeCreateArgs>
    ): CheckSelect<T, Prisma__ProgrammeClient<Programme>, Prisma__ProgrammeClient<ProgrammeGetPayload<T>>>

    /**
     * Create many Programmes.
     *     @param {ProgrammeCreateManyArgs} args - Arguments to create many Programmes.
     *     @example
     *     // Create many Programmes
     *     const programme = await prisma.programme.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProgrammeCreateManyArgs>(
      args?: SelectSubset<T, ProgrammeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Programme.
     * @param {ProgrammeDeleteArgs} args - Arguments to delete one Programme.
     * @example
     * // Delete one Programme
     * const Programme = await prisma.programme.delete({
     *   where: {
     *     // ... filter to delete one Programme
     *   }
     * })
     * 
    **/
    delete<T extends ProgrammeDeleteArgs>(
      args: SelectSubset<T, ProgrammeDeleteArgs>
    ): CheckSelect<T, Prisma__ProgrammeClient<Programme>, Prisma__ProgrammeClient<ProgrammeGetPayload<T>>>

    /**
     * Update one Programme.
     * @param {ProgrammeUpdateArgs} args - Arguments to update one Programme.
     * @example
     * // Update one Programme
     * const programme = await prisma.programme.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProgrammeUpdateArgs>(
      args: SelectSubset<T, ProgrammeUpdateArgs>
    ): CheckSelect<T, Prisma__ProgrammeClient<Programme>, Prisma__ProgrammeClient<ProgrammeGetPayload<T>>>

    /**
     * Delete zero or more Programmes.
     * @param {ProgrammeDeleteManyArgs} args - Arguments to filter Programmes to delete.
     * @example
     * // Delete a few Programmes
     * const { count } = await prisma.programme.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProgrammeDeleteManyArgs>(
      args?: SelectSubset<T, ProgrammeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programmes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programmes
     * const programme = await prisma.programme.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProgrammeUpdateManyArgs>(
      args: SelectSubset<T, ProgrammeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Programme.
     * @param {ProgrammeUpsertArgs} args - Arguments to update or create a Programme.
     * @example
     * // Update or create a Programme
     * const programme = await prisma.programme.upsert({
     *   create: {
     *     // ... data to create a Programme
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Programme we want to update
     *   }
     * })
    **/
    upsert<T extends ProgrammeUpsertArgs>(
      args: SelectSubset<T, ProgrammeUpsertArgs>
    ): CheckSelect<T, Prisma__ProgrammeClient<Programme>, Prisma__ProgrammeClient<ProgrammeGetPayload<T>>>

    /**
     * Count the number of Programmes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeCountArgs} args - Arguments to filter Programmes to count.
     * @example
     * // Count the number of Programmes
     * const count = await prisma.programme.count({
     *   where: {
     *     // ... the filter for the Programmes we want to count
     *   }
     * })
    **/
    count<T extends ProgrammeCountArgs>(
      args?: Subset<T, ProgrammeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgrammeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Programme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgrammeAggregateArgs>(args: Subset<T, ProgrammeAggregateArgs>): PrismaPromise<GetProgrammeAggregateType<T>>

    /**
     * Group by Programme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgrammeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgrammeGroupByArgs['orderBy'] }
        : { orderBy?: ProgrammeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgrammeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgrammeGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Programme.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProgrammeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    faculty<T extends FacultyArgs = {}>(args?: Subset<T, FacultyArgs>): CheckSelect<T, Prisma__FacultyClient<Faculty | null >, Prisma__FacultyClient<FacultyGetPayload<T> | null >>;

    university<T extends UniversityArgs = {}>(args?: Subset<T, UniversityArgs>): CheckSelect<T, Prisma__UniversityClient<University | null >, Prisma__UniversityClient<UniversityGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Programme findUnique
   */
  export type ProgrammeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Programme
     * 
    **/
    select?: ProgrammeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProgrammeInclude | null
    /**
     * Throw an Error if a Programme can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Programme to fetch.
     * 
    **/
    where: ProgrammeWhereUniqueInput
  }


  /**
   * Programme findFirst
   */
  export type ProgrammeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Programme
     * 
    **/
    select?: ProgrammeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProgrammeInclude | null
    /**
     * Throw an Error if a Programme can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Programme to fetch.
     * 
    **/
    where?: ProgrammeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programmes to fetch.
     * 
    **/
    orderBy?: Enumerable<ProgrammeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programmes.
     * 
    **/
    cursor?: ProgrammeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programmes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programmes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programmes.
     * 
    **/
    distinct?: Enumerable<ProgrammeScalarFieldEnum>
  }


  /**
   * Programme findMany
   */
  export type ProgrammeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Programme
     * 
    **/
    select?: ProgrammeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProgrammeInclude | null
    /**
     * Filter, which Programmes to fetch.
     * 
    **/
    where?: ProgrammeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programmes to fetch.
     * 
    **/
    orderBy?: Enumerable<ProgrammeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programmes.
     * 
    **/
    cursor?: ProgrammeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programmes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programmes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProgrammeScalarFieldEnum>
  }


  /**
   * Programme create
   */
  export type ProgrammeCreateArgs = {
    /**
     * Select specific fields to fetch from the Programme
     * 
    **/
    select?: ProgrammeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProgrammeInclude | null
    /**
     * The data needed to create a Programme.
     * 
    **/
    data: XOR<ProgrammeCreateInput, ProgrammeUncheckedCreateInput>
  }


  /**
   * Programme createMany
   */
  export type ProgrammeCreateManyArgs = {
    /**
     * The data used to create many Programmes.
     * 
    **/
    data: Enumerable<ProgrammeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Programme update
   */
  export type ProgrammeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Programme
     * 
    **/
    select?: ProgrammeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProgrammeInclude | null
    /**
     * The data needed to update a Programme.
     * 
    **/
    data: XOR<ProgrammeUpdateInput, ProgrammeUncheckedUpdateInput>
    /**
     * Choose, which Programme to update.
     * 
    **/
    where: ProgrammeWhereUniqueInput
  }


  /**
   * Programme updateMany
   */
  export type ProgrammeUpdateManyArgs = {
    /**
     * The data used to update Programmes.
     * 
    **/
    data: XOR<ProgrammeUpdateManyMutationInput, ProgrammeUncheckedUpdateManyInput>
    /**
     * Filter which Programmes to update
     * 
    **/
    where?: ProgrammeWhereInput
  }


  /**
   * Programme upsert
   */
  export type ProgrammeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Programme
     * 
    **/
    select?: ProgrammeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProgrammeInclude | null
    /**
     * The filter to search for the Programme to update in case it exists.
     * 
    **/
    where: ProgrammeWhereUniqueInput
    /**
     * In case the Programme found by the `where` argument doesn't exist, create a new Programme with this data.
     * 
    **/
    create: XOR<ProgrammeCreateInput, ProgrammeUncheckedCreateInput>
    /**
     * In case the Programme was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProgrammeUpdateInput, ProgrammeUncheckedUpdateInput>
  }


  /**
   * Programme delete
   */
  export type ProgrammeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Programme
     * 
    **/
    select?: ProgrammeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProgrammeInclude | null
    /**
     * Filter which Programme to delete.
     * 
    **/
    where: ProgrammeWhereUniqueInput
  }


  /**
   * Programme deleteMany
   */
  export type ProgrammeDeleteManyArgs = {
    /**
     * Filter which Programmes to delete
     * 
    **/
    where?: ProgrammeWhereInput
  }


  /**
   * Programme without action
   */
  export type ProgrammeArgs = {
    /**
     * Select specific fields to fetch from the Programme
     * 
    **/
    select?: ProgrammeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProgrammeInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UniversityScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name'
  };

  export type UniversityScalarFieldEnum = (typeof UniversityScalarFieldEnum)[keyof typeof UniversityScalarFieldEnum]


  export const FacultyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    universityId: 'universityId'
  };

  export type FacultyScalarFieldEnum = (typeof FacultyScalarFieldEnum)[keyof typeof FacultyScalarFieldEnum]


  export const CurriculumScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CurriculumScalarFieldEnum = (typeof CurriculumScalarFieldEnum)[keyof typeof CurriculumScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    discipline: 'discipline',
    grade: 'grade',
    curriculumid: 'curriculumid'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const ProgrammeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    available_space: 'available_space',
    facultyid: 'facultyid',
    universityid: 'universityid'
  };

  export type ProgrammeScalarFieldEnum = (typeof ProgrammeScalarFieldEnum)[keyof typeof ProgrammeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type UniversityWhereInput = {
    AND?: Enumerable<UniversityWhereInput>
    OR?: Enumerable<UniversityWhereInput>
    NOT?: Enumerable<UniversityWhereInput>
    id?: IntFilter | number
    code?: StringFilter | string
    name?: StringFilter | string
    faculties?: FacultyListRelationFilter
    programmes?: ProgrammeListRelationFilter
  }

  export type UniversityOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    faculties?: FacultyOrderByRelationAggregateInput
    programmes?: ProgrammeOrderByRelationAggregateInput
  }

  export type UniversityWhereUniqueInput = {
    id?: number
  }

  export type UniversityOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    _count?: UniversityCountOrderByAggregateInput
    _avg?: UniversityAvgOrderByAggregateInput
    _max?: UniversityMaxOrderByAggregateInput
    _min?: UniversityMinOrderByAggregateInput
    _sum?: UniversitySumOrderByAggregateInput
  }

  export type UniversityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UniversityScalarWhereWithAggregatesInput>
    OR?: Enumerable<UniversityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UniversityScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type FacultyWhereInput = {
    AND?: Enumerable<FacultyWhereInput>
    OR?: Enumerable<FacultyWhereInput>
    NOT?: Enumerable<FacultyWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    university?: XOR<UniversityRelationFilter, UniversityWhereInput> | null
    universityId?: IntFilter | number
    programmes?: ProgrammeListRelationFilter
  }

  export type FacultyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    university?: UniversityOrderByWithRelationInput
    universityId?: SortOrder
    programmes?: ProgrammeOrderByRelationAggregateInput
  }

  export type FacultyWhereUniqueInput = {
    id?: number
  }

  export type FacultyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    universityId?: SortOrder
    _count?: FacultyCountOrderByAggregateInput
    _avg?: FacultyAvgOrderByAggregateInput
    _max?: FacultyMaxOrderByAggregateInput
    _min?: FacultyMinOrderByAggregateInput
    _sum?: FacultySumOrderByAggregateInput
  }

  export type FacultyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacultyScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacultyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacultyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    universityId?: IntWithAggregatesFilter | number
  }

  export type CurriculumWhereInput = {
    AND?: Enumerable<CurriculumWhereInput>
    OR?: Enumerable<CurriculumWhereInput>
    NOT?: Enumerable<CurriculumWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    subjects?: SubjectListRelationFilter
  }

  export type CurriculumOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subjects?: SubjectOrderByRelationAggregateInput
  }

  export type CurriculumWhereUniqueInput = {
    id?: number
  }

  export type CurriculumOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CurriculumCountOrderByAggregateInput
    _avg?: CurriculumAvgOrderByAggregateInput
    _max?: CurriculumMaxOrderByAggregateInput
    _min?: CurriculumMinOrderByAggregateInput
    _sum?: CurriculumSumOrderByAggregateInput
  }

  export type CurriculumScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CurriculumScalarWhereWithAggregatesInput>
    OR?: Enumerable<CurriculumScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CurriculumScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type SubjectWhereInput = {
    AND?: Enumerable<SubjectWhereInput>
    OR?: Enumerable<SubjectWhereInput>
    NOT?: Enumerable<SubjectWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    discipline?: StringFilter | string
    grade?: IntFilter | number
    curriculum?: XOR<CurriculumRelationFilter, CurriculumWhereInput> | null
    curriculumid?: IntFilter | number
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    discipline?: SortOrder
    grade?: SortOrder
    curriculum?: CurriculumOrderByWithRelationInput
    curriculumid?: SortOrder
  }

  export type SubjectWhereUniqueInput = {
    id?: number
  }

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    discipline?: SortOrder
    grade?: SortOrder
    curriculumid?: SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _avg?: SubjectAvgOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
    _sum?: SubjectSumOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubjectScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubjectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubjectScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    discipline?: StringWithAggregatesFilter | string
    grade?: IntWithAggregatesFilter | number
    curriculumid?: IntWithAggregatesFilter | number
  }

  export type ProgrammeWhereInput = {
    AND?: Enumerable<ProgrammeWhereInput>
    OR?: Enumerable<ProgrammeWhereInput>
    NOT?: Enumerable<ProgrammeWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    available_space?: IntFilter | number
    faculty?: XOR<FacultyRelationFilter, FacultyWhereInput> | null
    university?: XOR<UniversityRelationFilter, UniversityWhereInput> | null
    facultyid?: IntFilter | number
    universityid?: IntFilter | number
  }

  export type ProgrammeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    available_space?: SortOrder
    faculty?: FacultyOrderByWithRelationInput
    university?: UniversityOrderByWithRelationInput
    facultyid?: SortOrder
    universityid?: SortOrder
  }

  export type ProgrammeWhereUniqueInput = {
    id?: number
  }

  export type ProgrammeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    available_space?: SortOrder
    facultyid?: SortOrder
    universityid?: SortOrder
    _count?: ProgrammeCountOrderByAggregateInput
    _avg?: ProgrammeAvgOrderByAggregateInput
    _max?: ProgrammeMaxOrderByAggregateInput
    _min?: ProgrammeMinOrderByAggregateInput
    _sum?: ProgrammeSumOrderByAggregateInput
  }

  export type ProgrammeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProgrammeScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProgrammeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProgrammeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    available_space?: IntWithAggregatesFilter | number
    facultyid?: IntWithAggregatesFilter | number
    universityid?: IntWithAggregatesFilter | number
  }

  export type UniversityCreateInput = {
    code: string
    name: string
    faculties?: FacultyCreateNestedManyWithoutUniversityInput
    programmes?: ProgrammeCreateNestedManyWithoutUniversityInput
  }

  export type UniversityUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    faculties?: FacultyUncheckedCreateNestedManyWithoutUniversityInput
    programmes?: ProgrammeUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    faculties?: FacultyUpdateManyWithoutUniversityInput
    programmes?: ProgrammeUpdateManyWithoutUniversityInput
  }

  export type UniversityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    faculties?: FacultyUncheckedUpdateManyWithoutUniversityInput
    programmes?: ProgrammeUncheckedUpdateManyWithoutUniversityInput
  }

  export type UniversityCreateManyInput = {
    id?: number
    code: string
    name: string
  }

  export type UniversityUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UniversityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FacultyCreateInput = {
    name: string
    university?: UniversityCreateNestedOneWithoutFacultiesInput
    programmes?: ProgrammeCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateInput = {
    id?: number
    name: string
    universityId: number
    programmes?: ProgrammeUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    university?: UniversityUpdateOneWithoutFacultiesInput
    programmes?: ProgrammeUpdateManyWithoutFacultyInput
  }

  export type FacultyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    programmes?: ProgrammeUncheckedUpdateManyWithoutFacultyInput
  }

  export type FacultyCreateManyInput = {
    id?: number
    name: string
    universityId: number
  }

  export type FacultyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FacultyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
  }

  export type CurriculumCreateInput = {
    name: string
    subjects?: SubjectCreateNestedManyWithoutCurriculumInput
  }

  export type CurriculumUncheckedCreateInput = {
    id?: number
    name: string
    subjects?: SubjectUncheckedCreateNestedManyWithoutCurriculumInput
  }

  export type CurriculumUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    subjects?: SubjectUpdateManyWithoutCurriculumInput
  }

  export type CurriculumUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subjects?: SubjectUncheckedUpdateManyWithoutCurriculumInput
  }

  export type CurriculumCreateManyInput = {
    id?: number
    name: string
  }

  export type CurriculumUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CurriculumUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SubjectCreateInput = {
    name: string
    discipline: string
    grade: number
    curriculum?: CurriculumCreateNestedOneWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateInput = {
    id?: number
    name: string
    discipline: string
    grade: number
    curriculumid: number
  }

  export type SubjectUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    discipline?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    curriculum?: CurriculumUpdateOneWithoutSubjectsInput
  }

  export type SubjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    discipline?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    curriculumid?: IntFieldUpdateOperationsInput | number
  }

  export type SubjectCreateManyInput = {
    id?: number
    name: string
    discipline: string
    grade: number
    curriculumid: number
  }

  export type SubjectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    discipline?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
  }

  export type SubjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    discipline?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    curriculumid?: IntFieldUpdateOperationsInput | number
  }

  export type ProgrammeCreateInput = {
    name: string
    available_space: number
    faculty?: FacultyCreateNestedOneWithoutProgrammesInput
    university?: UniversityCreateNestedOneWithoutProgrammesInput
  }

  export type ProgrammeUncheckedCreateInput = {
    id?: number
    name: string
    available_space: number
    facultyid: number
    universityid: number
  }

  export type ProgrammeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    available_space?: IntFieldUpdateOperationsInput | number
    faculty?: FacultyUpdateOneWithoutProgrammesInput
    university?: UniversityUpdateOneWithoutProgrammesInput
  }

  export type ProgrammeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    available_space?: IntFieldUpdateOperationsInput | number
    facultyid?: IntFieldUpdateOperationsInput | number
    universityid?: IntFieldUpdateOperationsInput | number
  }

  export type ProgrammeCreateManyInput = {
    id?: number
    name: string
    available_space: number
    facultyid: number
    universityid: number
  }

  export type ProgrammeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    available_space?: IntFieldUpdateOperationsInput | number
  }

  export type ProgrammeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    available_space?: IntFieldUpdateOperationsInput | number
    facultyid?: IntFieldUpdateOperationsInput | number
    universityid?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type FacultyListRelationFilter = {
    every?: FacultyWhereInput
    some?: FacultyWhereInput
    none?: FacultyWhereInput
  }

  export type ProgrammeListRelationFilter = {
    every?: ProgrammeWhereInput
    some?: ProgrammeWhereInput
    none?: ProgrammeWhereInput
  }

  export type FacultyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgrammeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UniversityCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type UniversityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UniversityMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type UniversityMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type UniversitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type UniversityRelationFilter = {
    is?: UniversityWhereInput | null
    isNot?: UniversityWhereInput | null
  }

  export type FacultyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    universityId?: SortOrder
  }

  export type FacultyAvgOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
  }

  export type FacultyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    universityId?: SortOrder
  }

  export type FacultyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    universityId?: SortOrder
  }

  export type FacultySumOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
  }

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput
    some?: SubjectWhereInput
    none?: SubjectWhereInput
  }

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CurriculumCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CurriculumAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CurriculumMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CurriculumMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CurriculumSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CurriculumRelationFilter = {
    is?: CurriculumWhereInput | null
    isNot?: CurriculumWhereInput | null
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    discipline?: SortOrder
    grade?: SortOrder
    curriculumid?: SortOrder
  }

  export type SubjectAvgOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    curriculumid?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    discipline?: SortOrder
    grade?: SortOrder
    curriculumid?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    discipline?: SortOrder
    grade?: SortOrder
    curriculumid?: SortOrder
  }

  export type SubjectSumOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    curriculumid?: SortOrder
  }

  export type FacultyRelationFilter = {
    is?: FacultyWhereInput | null
    isNot?: FacultyWhereInput | null
  }

  export type ProgrammeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    available_space?: SortOrder
    facultyid?: SortOrder
    universityid?: SortOrder
  }

  export type ProgrammeAvgOrderByAggregateInput = {
    id?: SortOrder
    available_space?: SortOrder
    facultyid?: SortOrder
    universityid?: SortOrder
  }

  export type ProgrammeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    available_space?: SortOrder
    facultyid?: SortOrder
    universityid?: SortOrder
  }

  export type ProgrammeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    available_space?: SortOrder
    facultyid?: SortOrder
    universityid?: SortOrder
  }

  export type ProgrammeSumOrderByAggregateInput = {
    id?: SortOrder
    available_space?: SortOrder
    facultyid?: SortOrder
    universityid?: SortOrder
  }

  export type FacultyCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<FacultyCreateWithoutUniversityInput>, Enumerable<FacultyUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<FacultyCreateOrConnectWithoutUniversityInput>
    createMany?: FacultyCreateManyUniversityInputEnvelope
    connect?: Enumerable<FacultyWhereUniqueInput>
  }

  export type ProgrammeCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<ProgrammeCreateWithoutUniversityInput>, Enumerable<ProgrammeUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<ProgrammeCreateOrConnectWithoutUniversityInput>
    createMany?: ProgrammeCreateManyUniversityInputEnvelope
    connect?: Enumerable<ProgrammeWhereUniqueInput>
  }

  export type FacultyUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<FacultyCreateWithoutUniversityInput>, Enumerable<FacultyUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<FacultyCreateOrConnectWithoutUniversityInput>
    createMany?: FacultyCreateManyUniversityInputEnvelope
    connect?: Enumerable<FacultyWhereUniqueInput>
  }

  export type ProgrammeUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<ProgrammeCreateWithoutUniversityInput>, Enumerable<ProgrammeUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<ProgrammeCreateOrConnectWithoutUniversityInput>
    createMany?: ProgrammeCreateManyUniversityInputEnvelope
    connect?: Enumerable<ProgrammeWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FacultyUpdateManyWithoutUniversityInput = {
    create?: XOR<Enumerable<FacultyCreateWithoutUniversityInput>, Enumerable<FacultyUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<FacultyCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<FacultyUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: FacultyCreateManyUniversityInputEnvelope
    set?: Enumerable<FacultyWhereUniqueInput>
    disconnect?: Enumerable<FacultyWhereUniqueInput>
    delete?: Enumerable<FacultyWhereUniqueInput>
    connect?: Enumerable<FacultyWhereUniqueInput>
    update?: Enumerable<FacultyUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<FacultyUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<FacultyScalarWhereInput>
  }

  export type ProgrammeUpdateManyWithoutUniversityInput = {
    create?: XOR<Enumerable<ProgrammeCreateWithoutUniversityInput>, Enumerable<ProgrammeUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<ProgrammeCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<ProgrammeUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: ProgrammeCreateManyUniversityInputEnvelope
    set?: Enumerable<ProgrammeWhereUniqueInput>
    disconnect?: Enumerable<ProgrammeWhereUniqueInput>
    delete?: Enumerable<ProgrammeWhereUniqueInput>
    connect?: Enumerable<ProgrammeWhereUniqueInput>
    update?: Enumerable<ProgrammeUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<ProgrammeUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<ProgrammeScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FacultyUncheckedUpdateManyWithoutUniversityInput = {
    create?: XOR<Enumerable<FacultyCreateWithoutUniversityInput>, Enumerable<FacultyUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<FacultyCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<FacultyUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: FacultyCreateManyUniversityInputEnvelope
    set?: Enumerable<FacultyWhereUniqueInput>
    disconnect?: Enumerable<FacultyWhereUniqueInput>
    delete?: Enumerable<FacultyWhereUniqueInput>
    connect?: Enumerable<FacultyWhereUniqueInput>
    update?: Enumerable<FacultyUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<FacultyUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<FacultyScalarWhereInput>
  }

  export type ProgrammeUncheckedUpdateManyWithoutUniversityInput = {
    create?: XOR<Enumerable<ProgrammeCreateWithoutUniversityInput>, Enumerable<ProgrammeUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<ProgrammeCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<ProgrammeUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: ProgrammeCreateManyUniversityInputEnvelope
    set?: Enumerable<ProgrammeWhereUniqueInput>
    disconnect?: Enumerable<ProgrammeWhereUniqueInput>
    delete?: Enumerable<ProgrammeWhereUniqueInput>
    connect?: Enumerable<ProgrammeWhereUniqueInput>
    update?: Enumerable<ProgrammeUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<ProgrammeUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<ProgrammeScalarWhereInput>
  }

  export type UniversityCreateNestedOneWithoutFacultiesInput = {
    create?: XOR<UniversityCreateWithoutFacultiesInput, UniversityUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutFacultiesInput
    connect?: UniversityWhereUniqueInput
  }

  export type ProgrammeCreateNestedManyWithoutFacultyInput = {
    create?: XOR<Enumerable<ProgrammeCreateWithoutFacultyInput>, Enumerable<ProgrammeUncheckedCreateWithoutFacultyInput>>
    connectOrCreate?: Enumerable<ProgrammeCreateOrConnectWithoutFacultyInput>
    createMany?: ProgrammeCreateManyFacultyInputEnvelope
    connect?: Enumerable<ProgrammeWhereUniqueInput>
  }

  export type ProgrammeUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<Enumerable<ProgrammeCreateWithoutFacultyInput>, Enumerable<ProgrammeUncheckedCreateWithoutFacultyInput>>
    connectOrCreate?: Enumerable<ProgrammeCreateOrConnectWithoutFacultyInput>
    createMany?: ProgrammeCreateManyFacultyInputEnvelope
    connect?: Enumerable<ProgrammeWhereUniqueInput>
  }

  export type UniversityUpdateOneWithoutFacultiesInput = {
    create?: XOR<UniversityCreateWithoutFacultiesInput, UniversityUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutFacultiesInput
    upsert?: UniversityUpsertWithoutFacultiesInput
    disconnect?: boolean
    delete?: boolean
    connect?: UniversityWhereUniqueInput
    update?: XOR<UniversityUpdateWithoutFacultiesInput, UniversityUncheckedUpdateWithoutFacultiesInput>
  }

  export type ProgrammeUpdateManyWithoutFacultyInput = {
    create?: XOR<Enumerable<ProgrammeCreateWithoutFacultyInput>, Enumerable<ProgrammeUncheckedCreateWithoutFacultyInput>>
    connectOrCreate?: Enumerable<ProgrammeCreateOrConnectWithoutFacultyInput>
    upsert?: Enumerable<ProgrammeUpsertWithWhereUniqueWithoutFacultyInput>
    createMany?: ProgrammeCreateManyFacultyInputEnvelope
    set?: Enumerable<ProgrammeWhereUniqueInput>
    disconnect?: Enumerable<ProgrammeWhereUniqueInput>
    delete?: Enumerable<ProgrammeWhereUniqueInput>
    connect?: Enumerable<ProgrammeWhereUniqueInput>
    update?: Enumerable<ProgrammeUpdateWithWhereUniqueWithoutFacultyInput>
    updateMany?: Enumerable<ProgrammeUpdateManyWithWhereWithoutFacultyInput>
    deleteMany?: Enumerable<ProgrammeScalarWhereInput>
  }

  export type ProgrammeUncheckedUpdateManyWithoutFacultyInput = {
    create?: XOR<Enumerable<ProgrammeCreateWithoutFacultyInput>, Enumerable<ProgrammeUncheckedCreateWithoutFacultyInput>>
    connectOrCreate?: Enumerable<ProgrammeCreateOrConnectWithoutFacultyInput>
    upsert?: Enumerable<ProgrammeUpsertWithWhereUniqueWithoutFacultyInput>
    createMany?: ProgrammeCreateManyFacultyInputEnvelope
    set?: Enumerable<ProgrammeWhereUniqueInput>
    disconnect?: Enumerable<ProgrammeWhereUniqueInput>
    delete?: Enumerable<ProgrammeWhereUniqueInput>
    connect?: Enumerable<ProgrammeWhereUniqueInput>
    update?: Enumerable<ProgrammeUpdateWithWhereUniqueWithoutFacultyInput>
    updateMany?: Enumerable<ProgrammeUpdateManyWithWhereWithoutFacultyInput>
    deleteMany?: Enumerable<ProgrammeScalarWhereInput>
  }

  export type SubjectCreateNestedManyWithoutCurriculumInput = {
    create?: XOR<Enumerable<SubjectCreateWithoutCurriculumInput>, Enumerable<SubjectUncheckedCreateWithoutCurriculumInput>>
    connectOrCreate?: Enumerable<SubjectCreateOrConnectWithoutCurriculumInput>
    createMany?: SubjectCreateManyCurriculumInputEnvelope
    connect?: Enumerable<SubjectWhereUniqueInput>
  }

  export type SubjectUncheckedCreateNestedManyWithoutCurriculumInput = {
    create?: XOR<Enumerable<SubjectCreateWithoutCurriculumInput>, Enumerable<SubjectUncheckedCreateWithoutCurriculumInput>>
    connectOrCreate?: Enumerable<SubjectCreateOrConnectWithoutCurriculumInput>
    createMany?: SubjectCreateManyCurriculumInputEnvelope
    connect?: Enumerable<SubjectWhereUniqueInput>
  }

  export type SubjectUpdateManyWithoutCurriculumInput = {
    create?: XOR<Enumerable<SubjectCreateWithoutCurriculumInput>, Enumerable<SubjectUncheckedCreateWithoutCurriculumInput>>
    connectOrCreate?: Enumerable<SubjectCreateOrConnectWithoutCurriculumInput>
    upsert?: Enumerable<SubjectUpsertWithWhereUniqueWithoutCurriculumInput>
    createMany?: SubjectCreateManyCurriculumInputEnvelope
    set?: Enumerable<SubjectWhereUniqueInput>
    disconnect?: Enumerable<SubjectWhereUniqueInput>
    delete?: Enumerable<SubjectWhereUniqueInput>
    connect?: Enumerable<SubjectWhereUniqueInput>
    update?: Enumerable<SubjectUpdateWithWhereUniqueWithoutCurriculumInput>
    updateMany?: Enumerable<SubjectUpdateManyWithWhereWithoutCurriculumInput>
    deleteMany?: Enumerable<SubjectScalarWhereInput>
  }

  export type SubjectUncheckedUpdateManyWithoutCurriculumInput = {
    create?: XOR<Enumerable<SubjectCreateWithoutCurriculumInput>, Enumerable<SubjectUncheckedCreateWithoutCurriculumInput>>
    connectOrCreate?: Enumerable<SubjectCreateOrConnectWithoutCurriculumInput>
    upsert?: Enumerable<SubjectUpsertWithWhereUniqueWithoutCurriculumInput>
    createMany?: SubjectCreateManyCurriculumInputEnvelope
    set?: Enumerable<SubjectWhereUniqueInput>
    disconnect?: Enumerable<SubjectWhereUniqueInput>
    delete?: Enumerable<SubjectWhereUniqueInput>
    connect?: Enumerable<SubjectWhereUniqueInput>
    update?: Enumerable<SubjectUpdateWithWhereUniqueWithoutCurriculumInput>
    updateMany?: Enumerable<SubjectUpdateManyWithWhereWithoutCurriculumInput>
    deleteMany?: Enumerable<SubjectScalarWhereInput>
  }

  export type CurriculumCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<CurriculumCreateWithoutSubjectsInput, CurriculumUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: CurriculumCreateOrConnectWithoutSubjectsInput
    connect?: CurriculumWhereUniqueInput
  }

  export type CurriculumUpdateOneWithoutSubjectsInput = {
    create?: XOR<CurriculumCreateWithoutSubjectsInput, CurriculumUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: CurriculumCreateOrConnectWithoutSubjectsInput
    upsert?: CurriculumUpsertWithoutSubjectsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CurriculumWhereUniqueInput
    update?: XOR<CurriculumUpdateWithoutSubjectsInput, CurriculumUncheckedUpdateWithoutSubjectsInput>
  }

  export type FacultyCreateNestedOneWithoutProgrammesInput = {
    create?: XOR<FacultyCreateWithoutProgrammesInput, FacultyUncheckedCreateWithoutProgrammesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutProgrammesInput
    connect?: FacultyWhereUniqueInput
  }

  export type UniversityCreateNestedOneWithoutProgrammesInput = {
    create?: XOR<UniversityCreateWithoutProgrammesInput, UniversityUncheckedCreateWithoutProgrammesInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutProgrammesInput
    connect?: UniversityWhereUniqueInput
  }

  export type FacultyUpdateOneWithoutProgrammesInput = {
    create?: XOR<FacultyCreateWithoutProgrammesInput, FacultyUncheckedCreateWithoutProgrammesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutProgrammesInput
    upsert?: FacultyUpsertWithoutProgrammesInput
    disconnect?: boolean
    delete?: boolean
    connect?: FacultyWhereUniqueInput
    update?: XOR<FacultyUpdateWithoutProgrammesInput, FacultyUncheckedUpdateWithoutProgrammesInput>
  }

  export type UniversityUpdateOneWithoutProgrammesInput = {
    create?: XOR<UniversityCreateWithoutProgrammesInput, UniversityUncheckedCreateWithoutProgrammesInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutProgrammesInput
    upsert?: UniversityUpsertWithoutProgrammesInput
    disconnect?: boolean
    delete?: boolean
    connect?: UniversityWhereUniqueInput
    update?: XOR<UniversityUpdateWithoutProgrammesInput, UniversityUncheckedUpdateWithoutProgrammesInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type FacultyCreateWithoutUniversityInput = {
    name: string
    programmes?: ProgrammeCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutUniversityInput = {
    id?: number
    name: string
    programmes?: ProgrammeUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutUniversityInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutUniversityInput, FacultyUncheckedCreateWithoutUniversityInput>
  }

  export type FacultyCreateManyUniversityInputEnvelope = {
    data: Enumerable<FacultyCreateManyUniversityInput>
    skipDuplicates?: boolean
  }

  export type ProgrammeCreateWithoutUniversityInput = {
    name: string
    available_space: number
    faculty?: FacultyCreateNestedOneWithoutProgrammesInput
  }

  export type ProgrammeUncheckedCreateWithoutUniversityInput = {
    id?: number
    name: string
    available_space: number
    facultyid: number
  }

  export type ProgrammeCreateOrConnectWithoutUniversityInput = {
    where: ProgrammeWhereUniqueInput
    create: XOR<ProgrammeCreateWithoutUniversityInput, ProgrammeUncheckedCreateWithoutUniversityInput>
  }

  export type ProgrammeCreateManyUniversityInputEnvelope = {
    data: Enumerable<ProgrammeCreateManyUniversityInput>
    skipDuplicates?: boolean
  }

  export type FacultyUpsertWithWhereUniqueWithoutUniversityInput = {
    where: FacultyWhereUniqueInput
    update: XOR<FacultyUpdateWithoutUniversityInput, FacultyUncheckedUpdateWithoutUniversityInput>
    create: XOR<FacultyCreateWithoutUniversityInput, FacultyUncheckedCreateWithoutUniversityInput>
  }

  export type FacultyUpdateWithWhereUniqueWithoutUniversityInput = {
    where: FacultyWhereUniqueInput
    data: XOR<FacultyUpdateWithoutUniversityInput, FacultyUncheckedUpdateWithoutUniversityInput>
  }

  export type FacultyUpdateManyWithWhereWithoutUniversityInput = {
    where: FacultyScalarWhereInput
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyWithoutFacultiesInput>
  }

  export type FacultyScalarWhereInput = {
    AND?: Enumerable<FacultyScalarWhereInput>
    OR?: Enumerable<FacultyScalarWhereInput>
    NOT?: Enumerable<FacultyScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    universityId?: IntFilter | number
  }

  export type ProgrammeUpsertWithWhereUniqueWithoutUniversityInput = {
    where: ProgrammeWhereUniqueInput
    update: XOR<ProgrammeUpdateWithoutUniversityInput, ProgrammeUncheckedUpdateWithoutUniversityInput>
    create: XOR<ProgrammeCreateWithoutUniversityInput, ProgrammeUncheckedCreateWithoutUniversityInput>
  }

  export type ProgrammeUpdateWithWhereUniqueWithoutUniversityInput = {
    where: ProgrammeWhereUniqueInput
    data: XOR<ProgrammeUpdateWithoutUniversityInput, ProgrammeUncheckedUpdateWithoutUniversityInput>
  }

  export type ProgrammeUpdateManyWithWhereWithoutUniversityInput = {
    where: ProgrammeScalarWhereInput
    data: XOR<ProgrammeUpdateManyMutationInput, ProgrammeUncheckedUpdateManyWithoutProgrammesInput>
  }

  export type ProgrammeScalarWhereInput = {
    AND?: Enumerable<ProgrammeScalarWhereInput>
    OR?: Enumerable<ProgrammeScalarWhereInput>
    NOT?: Enumerable<ProgrammeScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    available_space?: IntFilter | number
    facultyid?: IntFilter | number
    universityid?: IntFilter | number
  }

  export type UniversityCreateWithoutFacultiesInput = {
    code: string
    name: string
    programmes?: ProgrammeCreateNestedManyWithoutUniversityInput
  }

  export type UniversityUncheckedCreateWithoutFacultiesInput = {
    id?: number
    code: string
    name: string
    programmes?: ProgrammeUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityCreateOrConnectWithoutFacultiesInput = {
    where: UniversityWhereUniqueInput
    create: XOR<UniversityCreateWithoutFacultiesInput, UniversityUncheckedCreateWithoutFacultiesInput>
  }

  export type ProgrammeCreateWithoutFacultyInput = {
    name: string
    available_space: number
    university?: UniversityCreateNestedOneWithoutProgrammesInput
  }

  export type ProgrammeUncheckedCreateWithoutFacultyInput = {
    id?: number
    name: string
    available_space: number
    universityid: number
  }

  export type ProgrammeCreateOrConnectWithoutFacultyInput = {
    where: ProgrammeWhereUniqueInput
    create: XOR<ProgrammeCreateWithoutFacultyInput, ProgrammeUncheckedCreateWithoutFacultyInput>
  }

  export type ProgrammeCreateManyFacultyInputEnvelope = {
    data: Enumerable<ProgrammeCreateManyFacultyInput>
    skipDuplicates?: boolean
  }

  export type UniversityUpsertWithoutFacultiesInput = {
    update: XOR<UniversityUpdateWithoutFacultiesInput, UniversityUncheckedUpdateWithoutFacultiesInput>
    create: XOR<UniversityCreateWithoutFacultiesInput, UniversityUncheckedCreateWithoutFacultiesInput>
  }

  export type UniversityUpdateWithoutFacultiesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programmes?: ProgrammeUpdateManyWithoutUniversityInput
  }

  export type UniversityUncheckedUpdateWithoutFacultiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programmes?: ProgrammeUncheckedUpdateManyWithoutUniversityInput
  }

  export type ProgrammeUpsertWithWhereUniqueWithoutFacultyInput = {
    where: ProgrammeWhereUniqueInput
    update: XOR<ProgrammeUpdateWithoutFacultyInput, ProgrammeUncheckedUpdateWithoutFacultyInput>
    create: XOR<ProgrammeCreateWithoutFacultyInput, ProgrammeUncheckedCreateWithoutFacultyInput>
  }

  export type ProgrammeUpdateWithWhereUniqueWithoutFacultyInput = {
    where: ProgrammeWhereUniqueInput
    data: XOR<ProgrammeUpdateWithoutFacultyInput, ProgrammeUncheckedUpdateWithoutFacultyInput>
  }

  export type ProgrammeUpdateManyWithWhereWithoutFacultyInput = {
    where: ProgrammeScalarWhereInput
    data: XOR<ProgrammeUpdateManyMutationInput, ProgrammeUncheckedUpdateManyWithoutProgrammesInput>
  }

  export type SubjectCreateWithoutCurriculumInput = {
    name: string
    discipline: string
    grade: number
  }

  export type SubjectUncheckedCreateWithoutCurriculumInput = {
    id?: number
    name: string
    discipline: string
    grade: number
  }

  export type SubjectCreateOrConnectWithoutCurriculumInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutCurriculumInput, SubjectUncheckedCreateWithoutCurriculumInput>
  }

  export type SubjectCreateManyCurriculumInputEnvelope = {
    data: Enumerable<SubjectCreateManyCurriculumInput>
    skipDuplicates?: boolean
  }

  export type SubjectUpsertWithWhereUniqueWithoutCurriculumInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutCurriculumInput, SubjectUncheckedUpdateWithoutCurriculumInput>
    create: XOR<SubjectCreateWithoutCurriculumInput, SubjectUncheckedCreateWithoutCurriculumInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutCurriculumInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutCurriculumInput, SubjectUncheckedUpdateWithoutCurriculumInput>
  }

  export type SubjectUpdateManyWithWhereWithoutCurriculumInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type SubjectScalarWhereInput = {
    AND?: Enumerable<SubjectScalarWhereInput>
    OR?: Enumerable<SubjectScalarWhereInput>
    NOT?: Enumerable<SubjectScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    discipline?: StringFilter | string
    grade?: IntFilter | number
    curriculumid?: IntFilter | number
  }

  export type CurriculumCreateWithoutSubjectsInput = {
    name: string
  }

  export type CurriculumUncheckedCreateWithoutSubjectsInput = {
    id?: number
    name: string
  }

  export type CurriculumCreateOrConnectWithoutSubjectsInput = {
    where: CurriculumWhereUniqueInput
    create: XOR<CurriculumCreateWithoutSubjectsInput, CurriculumUncheckedCreateWithoutSubjectsInput>
  }

  export type CurriculumUpsertWithoutSubjectsInput = {
    update: XOR<CurriculumUpdateWithoutSubjectsInput, CurriculumUncheckedUpdateWithoutSubjectsInput>
    create: XOR<CurriculumCreateWithoutSubjectsInput, CurriculumUncheckedCreateWithoutSubjectsInput>
  }

  export type CurriculumUpdateWithoutSubjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CurriculumUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FacultyCreateWithoutProgrammesInput = {
    name: string
    university?: UniversityCreateNestedOneWithoutFacultiesInput
  }

  export type FacultyUncheckedCreateWithoutProgrammesInput = {
    id?: number
    name: string
    universityId: number
  }

  export type FacultyCreateOrConnectWithoutProgrammesInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutProgrammesInput, FacultyUncheckedCreateWithoutProgrammesInput>
  }

  export type UniversityCreateWithoutProgrammesInput = {
    code: string
    name: string
    faculties?: FacultyCreateNestedManyWithoutUniversityInput
  }

  export type UniversityUncheckedCreateWithoutProgrammesInput = {
    id?: number
    code: string
    name: string
    faculties?: FacultyUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityCreateOrConnectWithoutProgrammesInput = {
    where: UniversityWhereUniqueInput
    create: XOR<UniversityCreateWithoutProgrammesInput, UniversityUncheckedCreateWithoutProgrammesInput>
  }

  export type FacultyUpsertWithoutProgrammesInput = {
    update: XOR<FacultyUpdateWithoutProgrammesInput, FacultyUncheckedUpdateWithoutProgrammesInput>
    create: XOR<FacultyCreateWithoutProgrammesInput, FacultyUncheckedCreateWithoutProgrammesInput>
  }

  export type FacultyUpdateWithoutProgrammesInput = {
    name?: StringFieldUpdateOperationsInput | string
    university?: UniversityUpdateOneWithoutFacultiesInput
  }

  export type FacultyUncheckedUpdateWithoutProgrammesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
  }

  export type UniversityUpsertWithoutProgrammesInput = {
    update: XOR<UniversityUpdateWithoutProgrammesInput, UniversityUncheckedUpdateWithoutProgrammesInput>
    create: XOR<UniversityCreateWithoutProgrammesInput, UniversityUncheckedCreateWithoutProgrammesInput>
  }

  export type UniversityUpdateWithoutProgrammesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    faculties?: FacultyUpdateManyWithoutUniversityInput
  }

  export type UniversityUncheckedUpdateWithoutProgrammesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    faculties?: FacultyUncheckedUpdateManyWithoutUniversityInput
  }

  export type FacultyCreateManyUniversityInput = {
    id?: number
    name: string
  }

  export type ProgrammeCreateManyUniversityInput = {
    id?: number
    name: string
    available_space: number
    facultyid: number
  }

  export type FacultyUpdateWithoutUniversityInput = {
    name?: StringFieldUpdateOperationsInput | string
    programmes?: ProgrammeUpdateManyWithoutFacultyInput
  }

  export type FacultyUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    programmes?: ProgrammeUncheckedUpdateManyWithoutFacultyInput
  }

  export type FacultyUncheckedUpdateManyWithoutFacultiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProgrammeUpdateWithoutUniversityInput = {
    name?: StringFieldUpdateOperationsInput | string
    available_space?: IntFieldUpdateOperationsInput | number
    faculty?: FacultyUpdateOneWithoutProgrammesInput
  }

  export type ProgrammeUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    available_space?: IntFieldUpdateOperationsInput | number
    facultyid?: IntFieldUpdateOperationsInput | number
  }

  export type ProgrammeUncheckedUpdateManyWithoutProgrammesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    available_space?: IntFieldUpdateOperationsInput | number
    facultyid?: IntFieldUpdateOperationsInput | number
  }

  export type ProgrammeCreateManyFacultyInput = {
    id?: number
    name: string
    available_space: number
    universityid: number
  }

  export type ProgrammeUpdateWithoutFacultyInput = {
    name?: StringFieldUpdateOperationsInput | string
    available_space?: IntFieldUpdateOperationsInput | number
    university?: UniversityUpdateOneWithoutProgrammesInput
  }

  export type ProgrammeUncheckedUpdateWithoutFacultyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    available_space?: IntFieldUpdateOperationsInput | number
    universityid?: IntFieldUpdateOperationsInput | number
  }

  export type SubjectCreateManyCurriculumInput = {
    id?: number
    name: string
    discipline: string
    grade: number
  }

  export type SubjectUpdateWithoutCurriculumInput = {
    name?: StringFieldUpdateOperationsInput | string
    discipline?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
  }

  export type SubjectUncheckedUpdateWithoutCurriculumInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    discipline?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
  }

  export type SubjectUncheckedUpdateManyWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    discipline?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}